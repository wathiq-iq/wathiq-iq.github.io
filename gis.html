<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GQS/GPKG Project Viewer & Exporter</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        .sidebar {
            z-index: 1000;
            transition: transform 0.3s ease-in-out;
        }

        .layer-item:hover {
            background-color: #f3f4f6;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Dropdown menu animation */
        .dropdown-menu {
            transform-origin: top right;
            transition: transform 0.1s ease-out, opacity 0.1s ease-out;
        }
    </style>
</head>

<body class="flex flex-col md:flex-row bg-gray-100 font-sans">

    <!-- Sidebar -->
    <div id="sidebar"
        class="sidebar w-full md:w-80 bg-white h-1/2 md:h-full shadow-xl flex flex-col border-r border-gray-200 fixed md:relative bottom-0 md:top-0 transform translate-y-0 md:translate-y-0">
        <!-- Header -->
        <div class="p-4 bg-slate-800 text-white flex justify-between items-center shadow-md">
            <h1 class="text-lg font-bold"><i class="fa-solid fa-map-location-dot mr-2"></i>GeoProject View</h1>
            <button id="helpBtn" class="text-gray-300 hover:text-white" title="Help"><i
                    class="fa-solid fa-circle-question"></i></button>
        </div>

        <!-- Upload Area -->
        <div class="p-4 border-b border-gray-200 bg-gray-50">
            <div id="dropZone"
                class="border-2 border-dashed border-blue-300 rounded-lg p-6 text-center hover:bg-blue-50 transition cursor-pointer group">
                <i class="fa-solid fa-cloud-arrow-up text-3xl text-blue-400 mb-2 group-hover:scale-110 transition"></i>
                <p class="text-sm text-gray-600 font-medium">Drop .gpkg, .gqz, .qgs</p>
                <input type="file" id="fileInput" class="hidden" accept=".gpkg,.gqz,.qgs" multiple>
            </div>
            <div id="loadingIndicator" class="hidden mt-3 flex items-center justify-center gap-2 text-sm text-blue-600">
                <div class="loader"></div> Processing...
            </div>
        </div>

        <!-- Layer List -->
        <div class="flex-1 overflow-y-auto p-2" id="layerContainer">
            <div class="text-center text-gray-400 mt-10 text-sm">
                <p>No layers loaded.</p>
                <p class="text-xs mt-2">Upload a GeoPackage (.gpkg) to view data.</p>
                <p class="text-xs mt-1">Upload a Project (.gqz) to view structure.</p>
            </div>
        </div>

        <!-- Footer -->
        <div class="p-3 bg-gray-100 border-t border-gray-200 text-xs text-center text-gray-500">
            Rendered client-side using Leaflet & SQL.js
        </div>
    </div>

    <!-- Map Area -->
    <div class="flex-1 relative h-full">
        <div id="map"></div>

        <!-- Mobile Toggle -->
        <button id="sidebarToggle"
            class="md:hidden absolute bottom-4 right-4 z-[9999] bg-slate-800 text-white p-3 rounded-full shadow-lg">
            <i class="fa-solid fa-layer-group"></i>
        </button>
    </div>

    <!-- Modals -->
    <div id="errorModal" class="fixed inset-0 bg-black bg-opacity-50 z-[99999] hidden flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full mx-4">
            <h3 class="text-red-600 font-bold mb-2">Error</h3>
            <p id="errorMessage" class="text-gray-700 text-sm mb-4"></p>
            <button onclick="document.getElementById('errorModal').classList.add('hidden')"
                class="w-full bg-slate-800 text-white py-2 rounded hover:bg-slate-700">Close</button>
        </div>
    </div>

    <!-- External Libraries -->
    <!-- JSZip for .gqz and .kmz -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- SQL.js for .gpkg -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <!-- SheetJS for .xlsx/.xls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Leaflet -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        // --- CONFIG & STATE ---
        let map;
        let layers = {}; // ID -> { layer: LeafletLayer, name: string, type: string }
        let db = null; // SQLite DB instance
        let SQL = null;
        let activeDropdownId = null;

        // --- WKB UTILITIES (Binary Parsing) ---
        // Basic WKB parser specifically for GeoPackage geometry blobs
        function parseGeoPackageGeometry(buffer) {
            const view = new DataView(buffer);
            // GeoPackage Header Analysis
            const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));
            if (magic !== 'GP') return null; // Not a GeoPackage Blob

            const version = view.getUint8(2);
            const flags = view.getUint8(3);

            // Bit 0: Envelope Empty (1 = true)
            // Bit 1-3: Envelope Type (0=none, 1=32bytes, 2=48bytes, 3=64bytes, 4=80bytes)
            const envelopeType = (flags >> 1) & 0x07;
            let headerLength = 8; // Magic(2) + Ver(1) + Flags(1) + SRS_ID(4)

            // Add envelope size
            const envelopeSizes = [0, 32, 48, 64, 80];
            headerLength += envelopeSizes[envelopeType];

            // The rest is Standard WKB
            const wkbBuffer = buffer.slice(headerLength);
            return parseWKB(wkbBuffer);
        }

        function parseWKB(buffer) {
            const view = new DataView(buffer);
            let offset = 0;

            const byteOrder = view.getUint8(offset);
            const littleEndian = (byteOrder === 1);
            offset += 1;

            const wkbType = view.getUint32(offset, littleEndian);
            offset += 4;

            const geometryType = wkbType & 0xFF;

            switch (geometryType) {
                case 1: return parseWKBPoint(view, offset, littleEndian);
                case 2: return parseWKBLineString(view, offset, littleEndian);
                case 3: return parseWKBPolygon(view, offset, littleEndian);
                case 4: return parseWKBMultiPoint(view, offset, littleEndian);
                case 5: return parseWKBMultiLineString(view, offset, littleEndian);
                case 6: return parseWKBMultiPolygon(view, offset, littleEndian);
                default:
                    console.warn("Unsupported WKB Type:", geometryType);
                    return null;
            }
        }

        function parseWKBPoint(view, offset, littleEndian) {
            const x = view.getFloat64(offset, littleEndian);
            const y = view.getFloat64(offset + 8, littleEndian);
            return { type: "Point", coordinates: [x, y], newOffset: offset + 16 };
        }

        function parseWKBLineString(view, offset, littleEndian) {
            const numPoints = view.getUint32(offset, littleEndian);
            offset += 4;
            const coordinates = [];
            for (let i = 0; i < numPoints; i++) {
                const x = view.getFloat64(offset, littleEndian);
                const y = view.getFloat64(offset + 8, littleEndian);
                coordinates.push([x, y]);
                offset += 16;
            }
            return { type: "LineString", coordinates: coordinates, newOffset: offset };
        }

        function parseWKBPolygon(view, offset, littleEndian) {
            const numRings = view.getUint32(offset, littleEndian);
            offset += 4;
            const rings = [];
            for (let i = 0; i < numRings; i++) {
                const res = parseWKBLineString(view, offset, littleEndian);
                rings.push(res.coordinates);
                offset = res.newOffset;
            }
            return { type: "Polygon", coordinates: rings, newOffset: offset };
        }

        function parseWKBMultiPolygon(view, offset, littleEndian) {
            const numPolys = view.getUint32(offset, littleEndian);
            offset += 4;
            const polys = [];
            for (let i = 0; i < numPolys; i++) {
                offset += 5;
                const res = parseWKBPolygon(view, offset, littleEndian);
                polys.push(res.coordinates);
                offset = res.newOffset;
            }
            return { type: "MultiPolygon", coordinates: polys, newOffset: offset };
        }

        function parseWKBMultiLineString(view, offset, littleEndian) {
            const numLines = view.getUint32(offset, littleEndian);
            offset += 4;
            const lines = [];
            for (let i = 0; i < numLines; i++) {
                offset += 5; // Skip sub-header
                const res = parseWKBLineString(view, offset, littleEndian);
                lines.push(res.coordinates);
                offset = res.newOffset;
            }
            return { type: "MultiLineString", coordinates: lines, newOffset: offset };
        }

        function parseWKBMultiPoint(view, offset, littleEndian) {
            const numPoints = view.getUint32(offset, littleEndian);
            offset += 4;
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                offset += 5;
                const res = parseWKBPoint(view, offset, littleEndian);
                points.push(res.coordinates);
                offset = res.newOffset;
            }
            return { type: "MultiPoint", coordinates: points, newOffset: offset };
        }


        // --- APP LOGIC ---

        async function init() {
            // Init Leaflet
            map = L.map('map').setView([0, 0], 2);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap',
                subdomains: 'abcd',
                maxZoom: 20
            }).addTo(map);

            // Close dropdowns on click outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.layer-actions')) {
                    closeAllDropdowns();
                }
            });

            // Init SQL.js
            try {
                SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                });
            } catch (e) {
                console.error("Failed to load SQL.js", e);
                showError("Failed to initialize database engine. Check connection.");
            }

            setupEventListeners();
        }

        function setupEventListeners() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');

            dropZone.addEventListener('click', () => fileInput.click());
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('bg-blue-50', 'border-blue-500');
            });
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('bg-blue-50', 'border-blue-500');
            });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('bg-blue-50', 'border-blue-500');
                if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) handleFiles(e.target.files);
            });

            document.getElementById('sidebarToggle').addEventListener('click', () => {
                document.getElementById('sidebar').classList.toggle('translate-y-full');
            });
        }

        async function handleFiles(files) {
            document.getElementById('loadingIndicator').classList.remove('hidden');

            for (let file of files) {
                const ext = file.name.split('.').pop().toLowerCase();
                try {
                    if (ext === 'gpkg') {
                        await processGeoPackage(file);
                    } else if (ext === 'gqz' || ext === 'qgs') {
                        await processQGISProject(file);
                    } else {
                        showError(`Unsupported file type: .${ext}`);
                    }
                } catch (err) {
                    console.error(err);
                    showError(`Error processing ${file.name}: ${err.message}`);
                }
            }
            document.getElementById('loadingIndicator').classList.add('hidden');
        }

        async function processGeoPackage(file) {
            const buffer = await file.arrayBuffer();
            const uInt8Array = new Uint8Array(buffer);
            db = new SQL.Database(uInt8Array);
            const stmt = db.prepare("SELECT table_name, identifier FROM gpkg_contents WHERE data_type = 'features'");
            let loadedAny = false;
            while (stmt.step()) {
                const row = stmt.getAsObject();
                await loadLayerFromTable(row.table_name, row.identifier || row.table_name);
                loadedAny = true;
            }
            stmt.free();
            if (!loadedAny) showError("No feature tables found in this GeoPackage.");
        }

        async function loadLayerFromTable(tableName, displayName) {
            const colStmt = db.prepare(`SELECT column_name FROM gpkg_geometry_columns WHERE table_name = '${tableName}'`);
            let geomCol = 'geom';
            if (colStmt.step()) geomCol = colStmt.getAsObject().column_name;
            colStmt.free();

            const res = db.exec(`SELECT * FROM "${tableName}" LIMIT 2000`);
            if (res.length === 0) return;

            const columns = res[0].columns;
            const values = res[0].values;
            const geomIndex = columns.indexOf(geomCol);
            const geoJsonFeatures = [];

            values.forEach(row => {
                const geomData = row[geomIndex];
                if (!geomData) return;
                const geo = parseGeoPackageGeometry(geomData.buffer);
                if (geo) {
                    const props = {};
                    columns.forEach((col, idx) => {
                        if (idx !== geomIndex) props[col] = row[idx];
                    });
                    geoJsonFeatures.push({ type: "Feature", geometry: geo, properties: props });
                }
            });

            if (geoJsonFeatures.length > 0) {
                addLayerToMap(geoJsonFeatures, displayName);
            }
        }

        async function processQGISProject(file) {
            let xmlContent = "";
            if (file.name.endsWith('.gqz')) {
                const zip = new JSZip();
                const zipContent = await zip.loadAsync(file);
                const qgsFile = Object.keys(zipContent.files).find(n => n.endsWith('.qgs'));
                if (qgsFile) xmlContent = await zipContent.files[qgsFile].async("string");
                else throw new Error("Invalid .gqz file: No .qgs found.");
            } else {
                xmlContent = await file.text();
            }

            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            const projectTitle = xmlDoc.querySelector("title")?.textContent || file.name;
            const mapLayers = xmlDoc.querySelectorAll("maplayer");
            const layersList = [];

            mapLayers.forEach(layer => {
                const name = layer.querySelector("layername")?.textContent || "Unnamed";
                const type = layer.getAttribute("type");
                const source = layer.querySelector("datasource")?.textContent || "";
                layersList.push({ name, type, source });
            });

            renderProjectTree(projectTitle, layersList);
        }

        // --- UI & RENDERING ---

        function addLayerToMap(features, name) {
            const color = getRandomColor();
            const geoJsonLayer = L.geoJSON(features, {
                style: { color: color, weight: 2, opacity: 0.8, fillOpacity: 0.2 },
                pointToLayer: (feature, latlng) => L.circleMarker(latlng, { radius: 6, fillColor: color, color: "#fff", weight: 1, opacity: 1, fillOpacity: 0.8 }),
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = `<div class="text-sm font-bold border-b pb-1 mb-1">${name}</div><table class="text-xs">`;
                        for (const [key, value] of Object.entries(feature.properties)) {
                            popupContent += `<tr><td class="font-semibold pr-2">${key}:</td><td>${value}</td></tr>`;
                        }
                        popupContent += `</table>`;
                        layer.bindPopup(popupContent);
                    }
                }
            }).addTo(map);

            if (geoJsonLayer.getBounds().isValid()) map.fitBounds(geoJsonLayer.getBounds());

            const layerId = Date.now() + Math.random().toString(36).substr(2, 9);
            layers[layerId] = { layer: geoJsonLayer, name: name, type: 'vector', features: features };
            renderLayerItem(layerId, name);
        }

        function renderProjectTree(title, layersList) {
            const container = document.getElementById('layerContainer');
            if (container.querySelector('.text-center')) container.innerHTML = '';
            const projectDiv = document.createElement('div');
            projectDiv.className = "mb-4 bg-white rounded shadow-sm border border-gray-200";
            let html = `
                <div class="p-2 bg-slate-100 border-b border-gray-200 font-bold text-sm text-slate-700"><i class="fa-solid fa-folder-open mr-2 text-yellow-500"></i>${title} (QGIS)</div>
                <div class="p-2 text-xs text-gray-500 italic bg-yellow-50 border-b border-yellow-100"><i class="fa-solid fa-triangle-exclamation mr-1"></i> Structure only. Upload data to view map.</div>
                <ul class="text-sm">`;
            layersList.forEach(l => {
                let icon = l.type === 'vector' ? 'fa-draw-polygon' : l.type === 'raster' ? 'fa-image' : 'fa-layer-group';
                html += `<li class="p-2 flex items-center border-b border-gray-100 pl-4 text-gray-400"><i class="fa-solid ${icon} mr-2 w-4"></i><div class="truncate font-medium">${l.name}</div></li>`;
            });
            html += `</ul>`;
            container.prepend(projectDiv);
        }

        function renderLayerItem(id, name) {
            const container = document.getElementById('layerContainer');
            if (container.querySelector('.text-center')) container.innerHTML = '';

            const div = document.createElement('div');
            div.className = "layer-item mb-2 bg-white rounded shadow-sm border border-gray-200 p-2 flex items-center justify-between z-10 relative";
            div.innerHTML = `
                <div class="flex items-center flex-1 overflow-hidden">
                    <input type="checkbox" checked class="mr-2 h-4 w-4" onchange="toggleLayer('${id}', this.checked)">
                    <div class="truncate text-sm font-medium text-gray-700" title="${name}">${name}</div>
                </div>
                <div class="flex items-center gap-1 layer-actions relative">
                    <button onclick="zoomToLayer('${id}')" class="text-gray-400 hover:text-blue-600 p-1" title="Zoom"><i class="fa-solid fa-expand"></i></button>
                    
                    <div class="relative inline-block text-left">
                        <button onclick="toggleExportMenu('${id}')" class="text-gray-400 hover:text-green-600 p-1" title="Export"><i class="fa-solid fa-file-export"></i></button>
                        <div id="export-menu-${id}" class="hidden absolute right-0 mt-2 w-32 bg-white rounded-md shadow-lg ring-1 ring-black ring-opacity-5 z-50 dropdown-menu">
                            <div class="py-1">
                                <a href="#" onclick="exportData('${id}', 'geojson')" class="block px-4 py-2 text-xs text-gray-700 hover:bg-gray-100">GeoJSON</a>
                                <a href="#" onclick="exportData('${id}', 'kml')" class="block px-4 py-2 text-xs text-gray-700 hover:bg-gray-100">KML</a>
                                <a href="#" onclick="exportData('${id}', 'kmz')" class="block px-4 py-2 text-xs text-gray-700 hover:bg-gray-100">KMZ (Zipped)</a>
                                <a href="#" onclick="exportData('${id}', 'xlsx')" class="block px-4 py-2 text-xs text-gray-700 hover:bg-gray-100">Excel (.xlsx)</a>
                                <a href="#" onclick="exportData('${id}', 'xls')" class="block px-4 py-2 text-xs text-gray-700 hover:bg-gray-100">Excel 97 (.xls)</a>
                            </div>
                        </div>
                    </div>

                    <button onclick="removeLayer('${id}', this)" class="text-gray-400 hover:text-red-600 p-1" title="Remove"><i class="fa-solid fa-trash"></i></button>
                </div>
            `;
            container.appendChild(div);
        }

        // --- LAYER ACTIONS & EXPORT ---

        window.toggleLayer = (id, visible) => { if (layers[id]) visible ? map.addLayer(layers[id].layer) : map.removeLayer(layers[id].layer); };
        window.zoomToLayer = (id) => { if (layers[id] && layers[id].layer.getBounds().isValid()) map.fitBounds(layers[id].layer.getBounds()); };
        window.removeLayer = (id, btn) => { if (layers[id]) { map.removeLayer(layers[id].layer); delete layers[id]; btn.closest('.layer-item').remove(); } };

        window.toggleExportMenu = (id) => {
            const menu = document.getElementById(`export-menu-${id}`);
            if (activeDropdownId && activeDropdownId !== id) {
                document.getElementById(`export-menu-${activeDropdownId}`)?.classList.add('hidden');
            }
            if (menu.classList.contains('hidden')) {
                menu.classList.remove('hidden');
                activeDropdownId = id;
            } else {
                menu.classList.add('hidden');
                activeDropdownId = null;
            }
        };

        function closeAllDropdowns() {
            document.querySelectorAll('.dropdown-menu').forEach(el => el.classList.add('hidden'));
            activeDropdownId = null;
        }

        window.exportData = async (id, format) => {
            closeAllDropdowns();
            if (!layers[id]) return;

            const features = layers[id].features;
            const layerName = layers[id].name.replace(/[^a-z0-9]/gi, '_').toLowerCase();

            try {
                if (format === 'geojson') downloadFile(JSON.stringify({ type: "FeatureCollection", features }), layerName + ".geojson", "application/json");
                else if (format === 'kml') downloadFile(generateKML(features, layers[id].name), layerName + ".kml", "application/vnd.google-earth.kml+xml");
                else if (format === 'kmz') await generateKMZ(features, layers[id].name, layerName);
                else if (format === 'xlsx' || format === 'xls') generateExcel(features, layerName, format);
            } catch (e) {
                console.error(e);
                showError("Export failed: " + e.message);
            }
        };

        // --- EXPORT IMPLEMENTATIONS ---

        function generateKML(features, name) {
            let kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
<name>${name}</name>`;

            features.forEach(f => {
                let geomTag = "";
                const coords = f.geometry.coordinates;
                const type = f.geometry.type;

                // Simple geometry converter
                if (type === 'Point') {
                    geomTag = `<Point><coordinates>${coords[0]},${coords[1]}</coordinates></Point>`;
                } else if (type === 'LineString') {
                    geomTag = `<LineString><coordinates>${coords.map(c => c[0] + "," + c[1]).join(" ")}</coordinates></LineString>`;
                } else if (type === 'Polygon') {
                    // KML Polygons assume outer ring is first
                    let rings = coords.map(ring => `<LinearRing><coordinates>${ring.map(c => c[0] + "," + c[1]).join(" ")}</coordinates></LinearRing>`).join("");
                    geomTag = `<Polygon><outerBoundaryIs>${rings}</outerBoundaryIs></Polygon>`;
                }

                if (geomTag) {
                    let desc = "";
                    let extendedData = "<ExtendedData>";
                    for (let key in f.properties) {
                        extendedData += `<Data name="${key}"><value>${f.properties[key]}</value></Data>`;
                        desc += `<b>${key}:</b> ${f.properties[key]}<br>`;
                    }
                    extendedData += "</ExtendedData>";

                    kml += `
  <Placemark>
    <description><![CDATA[${desc}]]></description>
    ${extendedData}
    ${geomTag}
  </Placemark>`;
                }
            });

            kml += `</Document></kml>`;
            return kml;
        }

        async function generateKMZ(features, name, filename) {
            const kml = generateKML(features, name);
            const zip = new JSZip();
            zip.file("doc.kml", kml);
            const content = await zip.generateAsync({ type: "blob" });
            const url = URL.createObjectURL(content);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename + ".kmz";
            a.click();
            URL.revokeObjectURL(url);
        }

        function generateExcel(features, filename, ext) {
            // Flatten data
            const rows = features.map(f => {
                const row = { ...f.properties };

                // Add geometry info for user convenience
                if (f.geometry.type === 'Point') {
                    row._longitude = f.geometry.coordinates[0];
                    row._latitude = f.geometry.coordinates[1];
                } else {
                    row._geometry_type = f.geometry.type;
                    // Simple WKT-like representation for non-points
                    row._geometry_wkt = JSON.stringify(f.geometry.coordinates).substring(0, 32000); // Excel cell limit
                }
                return row;
            });

            const worksheet = XLSX.utils.json_to_sheet(rows);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Data");
            XLSX.writeFile(workbook, `${filename}.${ext}`);
        }

        function downloadFile(content, fileName, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
        }

        function showError(msg) {
            document.getElementById('errorMessage').textContent = msg;
            document.getElementById('errorModal').classList.remove('hidden');
        }

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Help Button
        document.getElementById('helpBtn').addEventListener('click', () => {
            alert("Instructions:\n1. Drag & Drop a .gpkg (GeoPackage) file to view map data.\n2. Use the Export button (Green Icon) next to a layer to download as KML, KMZ, Excel, or GeoJSON.");
        });

        // Start
        window.addEventListener('load', init);

    </script>
</body>

</html>
