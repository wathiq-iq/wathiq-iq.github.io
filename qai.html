<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø£Ø³Ø¦Ù„Ø© ÙˆØªØ­Ø¯ÙŠ ØµÙˆØ±</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ§ </text></svg>">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0369a1">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>
        body {
            font-family: 'Cairo', sans-serif;
            background-color: #f0f4f8;
        }
        .option-button, .mode-button, .action-btn {
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .option-button:hover:not(:disabled), .mode-button:hover:not(.bg-sky-700), .action-btn:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        .correct {
            background-color: #22c55e !important;
            color: white !important;
            border-color: #16a34a !important;
        }
        .incorrect {
            background-color: #ef4444 !important;
            color: white !important;
            border-color: #dc2626 !important;
        }
        .disabled-button, .mode-button.bg-sky-700, select:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .explanation-box, .hint-box, .why-wrong-box {
            background-color: #e0f2fe; 
            border: 1px solid #7dd3fc; 
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            margin-top: 0.75rem;
            font-size: 0.9rem;
            color: #075985; 
        }
        .hint-box {
            background-color: #ffedd5; 
            border-color: #fb923c; 
            color: #c2410c; 
        }
        .why-wrong-box {
            background-color: #fee2e2; /* Light red for why-wrong */
            border-color: #f87171;   /* Red border */
            color: #b91c1c;        /* Darker red text */
            margin-top: 0.25rem; /* Smaller margin for these specific explanations */
        }
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield; /* Firefox */
        }
        #generated-image-display {
            width: 100%;
            height: 250px; 
            object-fit: contain; 
            border-radius: 0.5rem;
        }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007CB2%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: left 0.5rem center;
            background-size: 0.65em auto;
            padding-left: 2rem; 
        }
         html[dir="rtl"] select {
            background-position: right 0.5rem center;
            padding-right: 2rem;
            padding-left: 0.75rem;
        }
        .why-wrong-btn {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            margin-top: 0.25rem;
            margin-right: 0.5rem; /* For RTL */
            background-color: #fbbf24; /* Amber 400 */
            color: #78350f; /* Amber 900 */
        }
        .why-wrong-btn:hover {
            background-color: #f59e0b; /* Amber 500 */
        }
    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen p-2 sm:p-4">
    <div class="bg-white p-4 sm:p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-2xl">
        <header class="mb-4 sm:mb-6 text-center">
            <h1 class="text-2xl sm:text-3xl md:text-4xl font-bold text-sky-700">Ù„Ø¹Ø¨Ø© Ø£Ø³Ø¦Ù„Ø© ÙˆØªØ­Ø¯ÙŠ ØµÙˆØ±</h1>
        </header>

        <div class="flex justify-center gap-2 sm:gap-4 mb-4 sm:mb-6">
            <button id="text-quiz-mode-button" class="mode-button flex-1 bg-sky-500 hover:bg-sky-600 text-white font-semibold py-2 px-3 sm:px-4 rounded-lg shadow-md">
                ğŸ“ Ù„Ø¹Ø¨Ø© Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„Ù†ØµÙŠØ©
            </button>
            <button id="image-quiz-mode-button" class="mode-button flex-1 bg-sky-500 hover:bg-sky-600 text-white font-semibold py-2 px-3 sm:px-4 rounded-lg shadow-md">
                ğŸ–¼ï¸ ØªØ­Ø¯ÙŠ Ø§Ù„ØµÙˆØ±
            </button>
        </div>

        <div id="score-container" class="mb-2 text-base sm:text-lg font-semibold text-slate-700 text-center">
            Ø§Ù„Ù†Ù‚Ø§Ø·: <span id="score" class="text-sky-600">0</span>
        </div>

        <div id="round-progress-container" class="mb-3 sm:mb-4 text-sm sm:text-md text-slate-600 text-center hidden">
        </div>

        <div id="text-quiz-section">
            <div id="question-container" class="mb-4 sm:mb-6 p-3 sm:p-5 bg-sky-50 rounded-lg shadow min-h-[80px] sm:min-h-[100px] flex items-center justify-center">
                <p id="question-text" class="text-lg sm:text-xl text-slate-800 text-center">Ø§Ø®ØªØ± ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨ØŒ Ø«Ù… Ø­Ø¯Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ÙˆØ§Ø¶ØºØ· "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø©"!</p>
            </div>
        </div>

        <div id="image-challenge-section" class="hidden">
            <div id="image-generation-loader-container" class="text-center mb-3 hidden">
                <div class="loader"></div>
                <p class="text-slate-600 text-sm">Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©...</p>
            </div>
            <div id="image-display-area" class="mb-4 h-56 sm:h-64 bg-slate-200 rounded-lg flex items-center justify-center overflow-hidden">
                <img id="generated-image-display" src="https://placehold.co/400x250/e2e8f0/94a3b8?text=Ø³ÙŠØªÙ…+Ø¹Ø±Ø¶+Ø§Ù„ØµÙˆØ±Ø©+Ù‡Ù†Ø§" alt="ØµÙˆØ±Ø© Ø§Ù„ØªØ­Ø¯ÙŠ" class="hidden"/>
                <p id="image-placeholder-text" class="text-slate-500 text-center p-4">Ø³ÙŠØªÙ… Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯Ù‡Ø§...</p>
            </div>
            <div id="image-question-loader-container" class="text-center mb-3 hidden">
                <div class="loader"></div>
                <p class="text-slate-600 text-sm">Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„ØµÙˆØ±Ø©...</p>
            </div>
            <div id="image-question-container" class="mb-4 sm:mb-6 p-3 sm:p-5 bg-sky-50 rounded-lg shadow min-h-[60px] sm:min-h-[80px] flex items-center justify-center">
                <p id="image-question-text" class="text-lg sm:text-xl text-slate-800 text-center"></p>
            </div>
        </div>

        <div id="hint-loader-container" class="text-center mb-2 hidden">
            <div class="loader"></div>
            <p class="text-slate-600 text-xs sm:text-sm">Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªÙ„Ù…ÙŠØ­...</p>
        </div>
        <div id="hint-container" class="mb-3 sm:mb-4 min-h-[18px] sm:min-h-[20px]">
        </div>
        
        <div id="options-container" class="grid grid-cols-1 sm:grid-cols-2 gap-2 sm:gap-3 md:gap-4 mb-4 sm:mb-6">
        </div>
         <!-- Container for "Why wrong?" explanations -->
        <div id="why-wrong-explanation-container" class="mb-3 sm:mb-4 min-h-[20px]"></div>


        <div id="feedback-container" class="mb-2 text-center min-h-[20px] sm:min-h-[24px]">
            <p id="feedback-text" class="text-md sm:text-lg font-medium"></p>
        </div>

        <div id="explanation-loader-container" class="text-center mb-2 hidden">
            <div class="loader"></div>
            <p class="text-slate-600 text-xs sm:text-sm">Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø´Ø±Ø­...</p>
        </div>
        <div id="explanation-container" class="mb-3 sm:mb-4 min-h-[18px] sm:min-h-[20px]">
        </div>
        
        <div class="flex flex-col sm:flex-row gap-2 mb-3 sm:mb-4">
            <button id="hint-button" class="action-btn flex-1 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 sm:py-2.5 px-3 sm:px-4 rounded-lg shadow-md hidden">
                ğŸ’¡ Ø£Ø¹Ø·Ù†ÙŠ ØªÙ„Ù…ÙŠØ­Ù‹Ø§
            </button>
            <button id="explain-answer-button" class="action-btn flex-1 bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 sm:py-2.5 px-3 sm:px-4 rounded-lg shadow-md hidden">
                âœ¨ Ø§Ø´Ø±Ø­ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
            </button>
        </div>


        <div id="round-setup-container" class="mb-3 sm:mb-4 p-3 sm:p-4 border border-slate-200 rounded-lg bg-slate-50">
            <div class="mb-2 sm:mb-3">
                <label for="num-questions-input" class="block text-xs sm:text-sm font-medium text-slate-700 mb-1">ğŸ¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©/Ø§Ù„ØµÙˆØ± ÙÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø©:</label>
                <input type="number" id="num-questions-input" name="num-questions-input" min="1" max="20" value="3" class="w-20 sm:w-24 p-1.5 sm:p-2 border border-slate-300 rounded-lg focus:ring-sky-500 focus:border-sky-500 text-center">
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                <div>
                    <label for="main-topic-select" class="block text-xs sm:text-sm font-medium text-slate-700 mb-1">ğŸ“š Ø§Ø®ØªØ± Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ:</label>
                    <select id="main-topic-select" class="w-full p-1.5 sm:p-2 border border-slate-300 rounded-lg focus:ring-sky-500 focus:border-sky-500 bg-white">
                        <option value="loading">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¶ÙŠØ¹...</option>
                    </select>
                </div>
                <div>
                    <label for="sub-topic-select" class="block text-xs sm:text-sm font-medium text-slate-700 mb-1">ğŸ” Ø§Ø®ØªØ± Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„ÙØ±Ø¹ÙŠ:</label>
                    <select id="sub-topic-select" class="w-full p-1.5 sm:p-2 border border-slate-300 rounded-lg focus:ring-sky-500 focus:border-sky-500 bg-white" disabled>
                        <option value="">Ø§Ø®ØªØ± Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ø£ÙˆÙ„Ø§Ù‹</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div id="action-buttons-container" class="mt-4">
            <button id="new-question-button" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2.5 sm:py-3 px-3 sm:px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50 transition duration-150 ease-in-out mb-2 sm:mb-3">
                Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø©
            </button>
            <button id="reset-game-button" class="w-full bg-amber-500 hover:bg-amber-600 text-white font-bold py-2.5 sm:py-3 px-3 sm:px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-amber-400 focus:ring-opacity-50 transition duration-150 ease-in-out">
                ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¨Ø¯Ø¡
            </button>
        </div>
    </div>

    <script type="module">
        // Firebase Imports
        import { initializeApp as initializeFirebaseApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"; 
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, Timestamp, collection, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // DOM Elements
        const textQuizModeButton = document.getElementById('text-quiz-mode-button');
        const imageQuizModeButton = document.getElementById('image-quiz-mode-button');
        const textQuizSection = document.getElementById('text-quiz-section');
        const imageChallengeSection = document.getElementById('image-challenge-section');
        
        const questionTextElement = document.getElementById('question-text'); 
        const imageGenerationLoader = document.getElementById('image-generation-loader-container');
        const generatedImageDisplay = document.getElementById('generated-image-display');
        const imagePlaceholderText = document.getElementById('image-placeholder-text');
        const imageQuestionLoader = document.getElementById('image-question-loader-container');
        const imageQuestionTextElement = document.getElementById('image-question-text'); 

        const optionsContainerElement = document.getElementById('options-container');
        const feedbackTextElement = document.getElementById('feedback-text');
        const newQuestionButton = document.getElementById('new-question-button');
        const scoreElement = document.getElementById('score');
        
        const hintButton = document.getElementById('hint-button');
        const hintContainer = document.getElementById('hint-container');
        const hintLoaderContainer = document.getElementById('hint-loader-container');
        
        const explainAnswerButton = document.getElementById('explain-answer-button');
        const explanationContainer = document.getElementById('explanation-container');
        const explanationLoaderContainer = document.getElementById('explanation-loader-container');
        const whyWrongExplanationContainer = document.getElementById('why-wrong-explanation-container');
        
        const mainTopicSelect = document.getElementById('main-topic-select');
        const subTopicSelect = document.getElementById('sub-topic-select');
        const numQuestionsInput = document.getElementById('num-questions-input');
        const roundProgressContainer = document.getElementById('round-progress-container');
        const resetGameButton = document.getElementById('reset-game-button');

        let currentQuizMode = 'text'; 
        let currentCorrectAnswerIndex = null;
        let currentQuestionFullText = ""; 
        let currentCorrectOptionText = "";
        let currentOptions = []; 
        let currentImageBase64 = null; 

        let score = 0;
        
        let totalQuestionsInRound = 0;
        let currentQuestionNumberInRound = 0;
        let isRoundActive = false;
        let currentRoundTopic = ""; 
        let askedQuestionsThisRound = []; 

        let toneJsStarted = false; 

        // --- API Configuration ---
        const apiKey = ""; 
        const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        
        const questionGenerationSchema = {
            responseMimeType: "application/json",
            responseSchema: {
                type: "OBJECT",
                properties: {
                    question: { type: "STRING", description: "The question in Arabic" },
                    options: {
                        type: "ARRAY",
                        description: "Four answer options in Arabic",
                        items: { type: "STRING" },
                        minItems: 4,
                        maxItems: 4
                    },
                    correctAnswerIndex: { type: "INTEGER", description: "The index of the correct answer (0-3)" , minimum: 0, maximum: 3 }
                },
                required: ["question", "options", "correctAnswerIndex"]
            }
        };
        
        const defaultTopicsData = {
            "Ø§Ù„ÙƒÙ„": [],
            "Ø§Ù„ØªØ§Ø±ÙŠØ®": ["Ø§Ù„ÙƒÙ„", "Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù‚Ø¯ÙŠÙ…", "Ø­Ø¶Ø§Ø±Ø§Øª Ù…Ø§ Ø¨ÙŠÙ† Ø§Ù„Ù†Ù‡Ø±ÙŠÙ†", "Ø§Ù„Ø­Ø¶Ø§Ø±Ø© Ø§Ù„ÙØ±Ø¹ÙˆÙ†ÙŠØ©", "Ø§Ù„ÙŠÙˆÙ†Ø§Ù† ÙˆØ§Ù„Ø±ÙˆÙ…Ø§Ù†", "Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„ÙˆØ³ÙŠØ·", "Ø§Ù„Ø¯ÙˆÙ„Ø© Ø§Ù„Ø¥Ø³Ù„Ø§Ù…ÙŠØ©", "Ø§Ù„Ø­Ù…Ù„Ø§Øª Ø§Ù„ØµÙ„ÙŠØ¨ÙŠØ©", "Ø§Ù„Ø¥Ù…Ø¨Ø±Ø§Ø·ÙˆØ±ÙŠØ© Ø§Ù„Ø¨ÙŠØ²Ù†Ø·ÙŠØ©", "Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ø­Ø¯ÙŠØ«", "Ø§Ù„Ø«ÙˆØ±Ø§Øª (Ø§Ù„ÙØ±Ù†Ø³ÙŠØ©ØŒ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠØ©ØŒ Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØ©)", "Ø§Ù„Ø§Ø³ØªØ¹Ù…Ø§Ø± ÙˆØ­Ø±ÙƒØ§Øª Ø§Ù„ØªØ­Ø±Ø±", "Ø§Ù„Ø­Ø±Ø¨Ø§Ù† Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØªØ§Ù†", "Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø¹Ø§ØµØ±", "Ø§Ù„Ø­Ø±Ø¨ Ø§Ù„Ø¨Ø§Ø±Ø¯Ø©", "Ø³Ù‚ÙˆØ· Ø§Ù„Ø§ØªØ­Ø§Ø¯ Ø§Ù„Ø³ÙˆÙÙŠØªÙŠ", "Ø§Ù„Ø«ÙˆØ±Ø§Øª Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"],
            "Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠØ§": ["Ø§Ù„ÙƒÙ„", "Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠØ§ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©", "Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠØ§ Ø§Ù„Ø¨Ø´Ø±ÙŠØ©", "Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠØ§ Ø§Ù„Ø§Ù‚ØªØµØ§Ø¯ÙŠØ©"],
            "Ø§Ù„Ø¹Ù„ÙˆÙ…": ["Ø§Ù„ÙƒÙ„", "Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡", "Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¡", "Ø§Ù„Ø¨ÙŠÙˆÙ„ÙˆØ¬ÙŠØ§", "Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª"],
            "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙˆØ§Ù„Ø±ÙˆØ¨ÙˆØªØ§Øª": ["Ø§Ù„ÙƒÙ„", "ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„Ø© ÙˆØ§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØªÙˆÙ„ÙŠØ¯ÙŠ", "Ø§Ù„Ø±ÙˆØ¨ÙˆØªØ§Øª Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©", "Ø£Ø®Ù„Ø§Ù‚ÙŠØ§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ", "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙÙŠ Ø§Ù„ÙÙ†ÙˆÙ† ÙˆØ§Ù„Ø¥Ø¨Ø¯Ø§Ø¹"],
            "Ø§Ù„Ø§Ø³ØªØ¯Ø§Ù…Ø© ÙˆØ§Ù„Ø¨ÙŠØ¦Ø©": ["Ø§Ù„ÙƒÙ„", "Ø§Ù„ØªØºÙŠØ± Ø§Ù„Ù…Ù†Ø§Ø®ÙŠ", "Ø§Ù„Ø·Ø§Ù‚Ø© Ø§Ù„Ù…ØªØ¬Ø¯Ø¯Ø©", "Ø§Ù„Ø²Ø±Ø§Ø¹Ø© Ø§Ù„Ø°ÙƒÙŠØ©", "Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø¨ÙŠØ¦ÙŠØ© ÙˆØ§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ù†Ø¸ÙŠÙØ©"],
            "Ø§Ù„ÙØ¶Ø§Ø¡ ÙˆØ§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„ÙƒÙˆÙ†": ["Ø§Ù„ÙƒÙ„", "Ø§Ù„Ø³ÙŠØ§Ø­Ø© Ø§Ù„ÙØ¶Ø§Ø¦ÙŠØ©", "Ù…Ø³ØªØ¹Ù…Ø±Ø§Øª Ø§Ù„Ù‚Ù…Ø± ÙˆØ§Ù„Ù…Ø±ÙŠØ®", "Ø§Ù„ØªÙ„Ø³ÙƒÙˆØ¨Ø§Øª Ø§Ù„Ø­Ø¯ÙŠØ«Ø©", "ÙÙŠØ²ÙŠØ§Ø¡ Ø§Ù„ÙØ¶Ø§Ø¡ ÙˆØ§Ù„Ø²Ù…Ù†"],
        };
        let dynamicTopicsData = { ...defaultTopicsData }; 

        // Firebase Configuration
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-quiz-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        let db, auth, currentUserId;

        if (firebaseConfig) {
            try {
                const firebaseApp = initializeFirebaseApp(firebaseConfig); 
                db = getFirestore(firebaseApp);
                auth = getAuth(firebaseApp);
                console.log("Firebase initialized successfully.");

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        console.log("User is signed in with UID:", currentUserId);
                        loadAndUpdateCategories(); // Load categories after user is signed in
                    } else {
                        currentUserId = null;
                        console.log("User is signed out. Using default categories.");
                        dynamicTopicsData = { ...defaultTopicsData }; // Fallback if sign-out happens before load
                        populateMainTopics();
                    }
                });


            } catch (e) {
                console.error("Error initializing Firebase:", e);
                db = null; auth = null; 
            }
        } else {
            console.warn("Firebase config not found. Firestore features will be disabled.");
            db = null; auth = null;
            dynamicTopicsData = { ...defaultTopicsData }; // Use default if no firebase
            populateMainTopics(); // Populate with default if no firebase
        }
        
        const categoriesDocPath = `/artifacts/${appId}/public/data/quiz_categories/current_topics`;

        async function signInUser() {
            if (!auth) return;
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Error signing in:", error);
                 // If sign-in fails, still try to load default categories
                dynamicTopicsData = { ...defaultTopicsData };
                populateMainTopics();
            }
        }


        // --- Sound Effects ---
        let synth; 

        function initializeTone() {
            if (!toneJsStarted && typeof Tone !== 'undefined') {
                synth = new Tone.Synth().toDestination();
                Tone.start(); 
                toneJsStarted = true;
                console.log("Tone.js started and synth initialized.");
            }
        }
        
        function playCorrectAnswerSound() {
            if (toneJsStarted && synth) {
                try {
                    synth.triggerAttackRelease("C5", "2n", Tone.now());
                    synth.triggerAttackRelease("G5", "4n", Tone.now() + 0.08);
                } catch (e) { console.error("Error playing correct sound:", e); }
            }
        }

        function playIncorrectAnswerSound() {
            if (toneJsStarted && synth) {
                try {
                    synth.triggerAttackRelease("C3", "8n", Tone.now());
                    synth.triggerAttackRelease("G2", "8n", Tone.now() + 0.2);
                } catch (e) { console.error("Error playing incorrect sound:", e); }
            }
        }

        function playWinSound() {
            if (toneJsStarted && synth) {
                try {
                    const now = Tone.now();
                    synth.triggerAttackRelease("C4", "8n", now);
                    synth.triggerAttackRelease("E4", "8n", now + 0.2);
                    synth.triggerAttackRelease("G4", "8n", now + 0.4);
                    synth.triggerAttackRelease("C5", "4n", now + 0.6);
                } catch (e) { console.error("Error playing win sound:", e); }
            }
        }

        async function fetchCategoriesFromGemini() {
            console.log("Fetching new categories from Gemini...");
            const prompt = "Please generate a list of diverse quiz categories. Provide exactly 10 main categories. For each main category, provide between 3 and 5 sub-categories. All categories and sub-categories must be in Classical Arabic. The response should be a JSON array of objects, where each object has a 'mainTopic' string and a 'subTopics' array of strings. Example: [{'mainTopic': 'Ø§Ù„ØªØ§Ø±ÙŠØ®', 'subTopics': ['Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù‚Ø¯ÙŠÙ…', 'Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ø­Ø¯ÙŠØ«']}, {'mainTopic': 'Ø§Ù„Ø¹Ù„ÙˆÙ…', 'subTopics': ['Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡', 'Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¡']}]. Ensure a good mix of topics including some from the following if possible: AI, Sustainability, Space, XR, Digital Culture, Neuroscience, Modern Education, Digital Economy, Digital Human Rights, Contemporary Arts, History, Geography, Religion, Science, Medicine, Literature, Art, Politics, Technology, Sports, Personalities, Current Events.";
            const schema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        mainTopic: { type: "STRING", description: "The main category name in Arabic." },
                        subTopics: {
                            type: "ARRAY",
                            description: "An array of sub-category names in Arabic for this main topic.",
                            items: { type: "STRING" }
                        }
                    },
                    required: ["mainTopic", "subTopics"]
                }
            };
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: { responseMimeType: "application/json", responseSchema: schema }
            };

            try {
                const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`Gemini API error for categories: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                    const categoriesArray = JSON.parse(result.candidates[0].content.parts[0].text);
                    const newTopicsData = { "Ø§Ù„ÙƒÙ„": [] }; 
                    categoriesArray.forEach(item => {
                        if (item.mainTopic && Array.isArray(item.subTopics)) {
                            newTopicsData[item.mainTopic] = ["Ø§Ù„ÙƒÙ„", ...item.subTopics]; 
                        }
                    });
                    console.log("Successfully fetched and processed categories from Gemini:", newTopicsData);
                    return newTopicsData;
                } else {
                    throw new Error("No valid category content in Gemini API response.");
                }
            } catch (error) {
                console.error("Error fetching categories from Gemini:", error);
                return null; 
            }
        }
        
        async function loadAndUpdateCategories() {
            if (!db || !currentUserId) { // Check if db is initialized and user is signed in
                console.log("Firestore not available or user not signed in, using default topics.");
                dynamicTopicsData = { ...defaultTopicsData };
                populateMainTopics();
                return;
            }

            const todayStr = new Date().toISOString().split('T')[0]; 
            const categoriesDocRef = doc(db, categoriesDocPath);

            try {
                const docSnap = await getDoc(categoriesDocRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data.last_fetched_date === todayStr && data.categories_json_string) {
                        console.log("Using categories from Firestore (fetched today).");
                        dynamicTopicsData = JSON.parse(data.categories_json_string);
                    } else {
                        console.log("Categories outdated or not found, fetching from Gemini...");
                        const newCategories = await fetchCategoriesFromGemini();
                        if (newCategories) {
                            dynamicTopicsData = newCategories;
                            await setDoc(categoriesDocRef, {
                                categories_json_string: JSON.stringify(newCategories),
                                last_fetched_date: todayStr,
                                timestamp: Timestamp.now()
                            });
                            console.log("Categories updated in Firestore.");
                        } else {
                            console.log("Failed to fetch new categories, using previous or default.");
                            if(data.categories_json_string) dynamicTopicsData = JSON.parse(data.categories_json_string); 
                            else dynamicTopicsData = { ...defaultTopicsData };
                        }
                    }
                } else {
                    console.log("No categories document found, fetching from Gemini for the first time...");
                    const newCategories = await fetchCategoriesFromGemini();
                    if (newCategories) {
                        dynamicTopicsData = newCategories;
                        await setDoc(categoriesDocRef, {
                            categories_json_string: JSON.stringify(newCategories),
                            last_fetched_date: todayStr,
                            timestamp: Timestamp.now()
                        });
                        console.log("Categories saved to Firestore for the first time.");
                    } else {
                         console.log("Failed to fetch new categories, using default.");
                        dynamicTopicsData = { ...defaultTopicsData };
                    }
                }
            } catch (error) {
                console.error("Error loading/updating categories from Firestore:", error);
                dynamicTopicsData = { ...defaultTopicsData }; 
            }
            populateMainTopics();
        }


        function populateMainTopics() {
            mainTopicSelect.innerHTML = ''; 
            Object.keys(dynamicTopicsData).forEach(topic => {
                const option = document.createElement('option');
                option.value = topic;
                option.textContent = topic;
                mainTopicSelect.appendChild(option);
            });
            populateSubTopics(); 
        }

        function populateSubTopics() {
            const selectedMainTopic = mainTopicSelect.value;
            subTopicSelect.innerHTML = ''; 
            const subtopics = dynamicTopicsData[selectedMainTopic];

            if (subtopics && subtopics.length > 0) {
                subtopics.forEach(subtopic => {
                    const option = document.createElement('option');
                    option.value = subtopic;
                    option.textContent = subtopic;
                    subTopicSelect.appendChild(option);
                });
                subTopicSelect.disabled = false;
            } else { 
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¶ÙŠØ¹ ÙØ±Ø¹ÙŠØ©";
                subTopicSelect.appendChild(option);
                subTopicSelect.disabled = true;
            }
            if (selectedMainTopic === "Ø§Ù„ÙƒÙ„") {
                subTopicSelect.disabled = true;
                 const option = document.createElement('option');
                option.value = "Ø§Ù„ÙƒÙ„"; 
                option.textContent = "Ø§Ù„ÙƒÙ„";
                subTopicSelect.innerHTML = ''; 
                subTopicSelect.appendChild(option);
            }
        }

        mainTopicSelect.addEventListener('change', populateSubTopics);


        function setQuizMode(mode) {
            initializeTone(); 
            currentQuizMode = mode;
            if (mode === 'text') {
                textQuizSection.classList.remove('hidden');
                imageChallengeSection.classList.add('hidden');
                textQuizModeButton.classList.add('bg-sky-700', 'disabled-button');
                textQuizModeButton.classList.remove('bg-sky-500', 'hover:bg-sky-600');
                imageQuizModeButton.classList.remove('bg-sky-700', 'disabled-button');
                imageQuizModeButton.classList.add('bg-sky-500', 'hover:bg-sky-600');
                questionTextElement.textContent = "Ø§Ø®ØªØ± ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨ØŒ Ø«Ù… Ø­Ø¯Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ÙˆØ§Ø¶ØºØ· \"Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø©\"!";
            } else if (mode === 'image') {
                textQuizSection.classList.add('hidden');
                imageChallengeSection.classList.remove('hidden');
                imageQuizModeButton.classList.add('bg-sky-700', 'disabled-button');
                imageQuizModeButton.classList.remove('bg-sky-500', 'hover:bg-sky-600');
                textQuizModeButton.classList.remove('bg-sky-700', 'disabled-button');
                textQuizModeButton.classList.add('bg-sky-500', 'hover:bg-sky-600');
                imageQuestionTextElement.textContent = "Ø§Ø®ØªØ± ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨ØŒ Ø«Ù… Ø­Ø¯Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ÙˆØ§Ø¶ØºØ· \"Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø©\"!";
            }
             if(isRoundActive) endRound(); 
        }
        
        function startNewRound() {
            initializeTone(); 
            const numQuestions = parseInt(numQuestionsInput.value);
            if (isNaN(numQuestions) || numQuestions < 1 || numQuestions > 100) { 
                feedbackTextElement.textContent = `Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ ${currentQuizMode === 'text' ? 'Ø£Ø³Ø¦Ù„Ø©' : 'ØµÙˆØ±'} ØµØ§Ù„Ø­ Ø¨ÙŠÙ† 1 Ùˆ 100.`;
                feedbackTextElement.classList.add('text-red-500');
                return;
            }
            feedbackTextElement.textContent = ""; 
            feedbackTextElement.classList.remove('text-red-500');

            totalQuestionsInRound = numQuestions;
            currentQuestionNumberInRound = 0;
            score = 0; 
            scoreElement.textContent = score;
            isRoundActive = true;
            
            const selectedMainTopic = mainTopicSelect.value;
            const selectedSubTopic = subTopicSelect.value;

            if (selectedMainTopic === "Ø§Ù„ÙƒÙ„" || !selectedMainTopic) {
                currentRoundTopic = ""; 
            } else if (selectedSubTopic === "Ø§Ù„ÙƒÙ„" || !selectedSubTopic) {
                currentRoundTopic = selectedMainTopic; 
            } else {
                currentRoundTopic = `${selectedMainTopic} - ${selectedSubTopic}`; 
            }
            console.log("Starting round with topic:", currentRoundTopic);


            askedQuestionsThisRound = []; 

            numQuestionsInput.disabled = true;
            mainTopicSelect.disabled = true;
            subTopicSelect.disabled = true;
            textQuizModeButton.disabled = true; textQuizModeButton.classList.add('disabled-button');
            imageQuizModeButton.disabled = true; imageQuizModeButton.classList.add('disabled-button');

            newQuestionButton.textContent = currentQuizMode === 'text' ? "Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„ØªØ§Ù„ÙŠ" : "Ø§Ù„ØªØ­Ø¯ÙŠ Ø§Ù„ØªØ§Ù„ÙŠ";
            roundProgressContainer.classList.remove('hidden');
            
            optionsContainerElement.innerHTML = ''; 
            explainAnswerButton.classList.add('hidden');
            explanationContainer.innerHTML = '';
            whyWrongExplanationContainer.innerHTML = ''; 
            hintButton.classList.add('hidden');
            hintContainer.innerHTML = '';

            if (currentQuizMode === 'text') {
                questionTextElement.textContent = "Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ø£ÙˆÙ„...";
                fetchNewTextQuestion();
            } else if (currentQuizMode === 'image') {
                imageQuestionTextElement.textContent = "Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„ØªØ­Ø¯ÙŠ Ø§Ù„Ø£ÙˆÙ„...";
                generatedImageDisplay.classList.add('hidden');
                imagePlaceholderText.classList.remove('hidden');
                imagePlaceholderText.textContent = "Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©...";
                fetchNewImageChallenge();
            }
        }

        async function saveScoreToFirestore() {
            if (!db || !currentUserId || !isRoundActive) { // Only save if round was active and user is signed in
                console.log("Firestore not available, user not signed in, or round not active. Score not saved.");
                return;
            }
            try {
                const scoresCollectionRef = collection(db, `/artifacts/${appId}/users/${currentUserId}/game_scores`);
                await addDoc(scoresCollectionRef, {
                    score: score,
                    totalQuestions: totalQuestionsInRound,
                    topic: currentRoundTopic || "Ø¹Ø§Ù…",
                    mode: currentQuizMode,
                    date: Timestamp.now()
                });
                console.log("Score saved to Firestore successfully.");
            } catch (error) {
                console.error("Error saving score to Firestore:", error);
            }
        }


        function endRound() {
            if(isRoundActive) { // Only save score if the round was actually active
                 saveScoreToFirestore();
            }
            isRoundActive = false;
            const mainQuestionDisplay = currentQuizMode === 'text' ? questionTextElement : imageQuestionTextElement;
            mainQuestionDisplay.textContent = `Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬ÙˆÙ„Ø©! Ù†ØªÙŠØ¬ØªÙƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${score} Ù…Ù† ${totalQuestionsInRound}`;
            
            if(currentQuizMode === 'image') {
                generatedImageDisplay.classList.add('hidden');
                imagePlaceholderText.classList.remove('hidden');
                imagePlaceholderText.textContent = `Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬ÙˆÙ„Ø©! Ù†ØªÙŠØ¬ØªÙƒ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${score} Ù…Ù† ${totalQuestionsInRound}`;
            }

            optionsContainerElement.innerHTML = '';
            feedbackTextElement.textContent = 'Ø£Ø­Ø³Ù†Øª!';
            feedbackTextElement.classList.remove('text-red-500', 'text-green-500');
            feedbackTextElement.classList.add('text-sky-600');
            playWinSound(); 

            explainAnswerButton.classList.add('hidden');
            explanationContainer.innerHTML = '';
            whyWrongExplanationContainer.innerHTML = '';
            hintButton.classList.add('hidden');
            hintContainer.innerHTML = '';
            newQuestionButton.textContent = "Ø§Ø¨Ø¯Ø£ Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©";
            numQuestionsInput.disabled = false;
            mainTopicSelect.disabled = false;
            subTopicSelect.disabled = mainTopicSelect.value === "Ø§Ù„ÙƒÙ„"; 
            textQuizModeButton.disabled = false; textQuizModeButton.classList.remove('disabled-button');
            imageQuizModeButton.disabled = false; imageQuizModeButton.classList.remove('disabled-button');
            roundProgressContainer.classList.add('hidden');
            currentQuestionNumberInRound = 0; 
        }

        async function fetchNewTextQuestion() {
            if (!isRoundActive || currentQuestionNumberInRound >= totalQuestionsInRound) {
                if(isRoundActive) endRound();
                return;
            }
            currentQuestionNumberInRound++;
            roundProgressContainer.textContent = `Ø§Ù„Ø³Ø¤Ø§Ù„ ${currentQuestionNumberInRound} Ù…Ù† ${totalQuestionsInRound}`;
            
            newQuestionButton.disabled = true; newQuestionButton.classList.add('disabled-button');
            textQuizSection.querySelector('#question-container').classList.remove('hidden'); 
            const textQuestionLoader = document.createElement('div'); 
            textQuestionLoader.className = 'loader';
            questionTextElement.innerHTML = ''; 
            questionTextElement.appendChild(textQuestionLoader);

            optionsContainerElement.innerHTML = '';
            feedbackTextElement.textContent = '';
            explainAnswerButton.classList.add('hidden');
            explanationContainer.innerHTML = '';
            whyWrongExplanationContainer.innerHTML = '';
            hintButton.classList.add('hidden'); 
            hintContainer.innerHTML = ''; 


            try {
                let basePrompt;
                if (currentRoundTopic) { 
                    basePrompt = `Generate a single quiz question about the topic: "${currentRoundTopic}". The question and its four answer options must be in Classical Arabic (Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰). Only one option should be correct. Provide diverse and clear options. Specify the index of the correct answer (0-3). Ensure the question is relevant to the given topic.`;
                } else { 
                    basePrompt = `Generate a single quiz question in the field of "${currentRoundTopic}". The question and its four answer options must be in Classical Arabic (Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰). Only one option should be correct. Provide diverse and clear options. Specify the index of the correct answer (0-3).`;
                }

                let prompt = basePrompt;
                if (askedQuestionsThisRound.length > 0) {
                    const exclusions = askedQuestionsThisRound.map(q => `"${q}"`).join(', ');
                    prompt += ` IMPORTANT: This question must be different from any of the following questions that have already been asked in this round: [${exclusions}].`;
                }

                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: questionGenerationSchema
                };
                const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API error (Text Question): ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                    const quizData = JSON.parse(result.candidates[0].content.parts[0].text);
                    if (quizData.question && quizData.options && quizData.options.length === 4 && quizData.correctAnswerIndex !== undefined) {
                        if (askedQuestionsThisRound.includes(quizData.question) && askedQuestionsThisRound.length < 5) { 
                            console.warn("Duplicate text question received, retrying...");
                            currentQuestionNumberInRound--; 
                            fetchNewTextQuestion();
                            return;
                        }
                        askedQuestionsThisRound.push(quizData.question); 
                        displayQuestion(quizData.question, quizData.options, quizData.correctAnswerIndex, questionTextElement);
                    } else throw new Error("Invalid data structure from API (Text Question).");
                } else throw new Error("No valid content in API response (Text Question).");
            } catch (error) {
                console.error('Error fetching text question:', error);
                questionTextElement.textContent = 'Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ù†ØµÙŠ.';
                feedbackTextElement.textContent = `Ø®Ø·Ø£: ${error.message}`;
                newQuestionButton.disabled = false; newQuestionButton.classList.remove('disabled-button');
            }
        }

        async function fetchNewImageChallenge() {
            if (!isRoundActive || currentQuestionNumberInRound >= totalQuestionsInRound) {
                 if(isRoundActive) endRound();
                return;
            }
            currentQuestionNumberInRound++;
            roundProgressContainer.textContent = `Ø§Ù„ØªØ­Ø¯ÙŠ ${currentQuestionNumberInRound} Ù…Ù† ${totalQuestionsInRound}`;

            newQuestionButton.disabled = true; newQuestionButton.classList.add('disabled-button');
            imageGenerationLoader.classList.remove('hidden');
            imageQuestionLoader.classList.add('hidden');
            generatedImageDisplay.classList.add('hidden');
            imagePlaceholderText.classList.remove('hidden');
            imagePlaceholderText.textContent = "Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©...";
            imageQuestionTextElement.textContent = '';
            optionsContainerElement.innerHTML = '';
            feedbackTextElement.textContent = '';
            explainAnswerButton.classList.add('hidden');
            explanationContainer.innerHTML = '';
            whyWrongExplanationContainer.innerHTML = '';
            hintButton.classList.add('hidden'); 
            hintContainer.innerHTML = ''; 
            currentImageBase64 = null;

            try {
                // 1. Generate Image with Imagen
                let imagePrompt = currentRoundTopic ? `A clear, interesting, and quiz-worthy image related to: "${currentRoundTopic}". Focus on a single subject or a clear scene.` : "A random interesting and clear image suitable for a visual quiz, like a famous landmark, an animal, an object, or a simple scene.";
                
                const correctedImagenPayload = {
                    instances: { prompt: imagePrompt },
                    parameters: { "sampleCount": 1 }
                };
                
                const currentImgApiKey = apiKey; 
                const localImagenApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${currentImgApiKey}`;
                
                console.log("Attempting Imagen API call to:", localImagenApiUrl); 
                console.log("Using API Key for Imagen (should be empty for Canvas injection): '", currentImgApiKey, "'"); 
                console.log("With Imagen payload:", JSON.stringify(correctedImagenPayload)); 
                
                const imagenResponse = await fetch(localImagenApiUrl, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(correctedImagenPayload) 
                });

                if (!imagenResponse.ok) {
                    const errorText = await imagenResponse.text();
                    console.error("Imagen API Response Error Text:", errorText);
                    throw new Error(`Imagen API error: ${imagenResponse.status}`); 
                }
                const imagenResult = await imagenResponse.json();

                if (!imagenResult.predictions || imagenResult.predictions.length === 0 || !imagenResult.predictions[0].bytesBase64Encoded) {
                    console.error("Imagen API - Invalid predictions structure:", imagenResult);
                    throw new Error("Failed to generate image or received invalid image data.");
                }
                currentImageBase64 = imagenResult.predictions[0].bytesBase64Encoded;
                generatedImageDisplay.src = `data:image/png;base64,${currentImageBase64}`;
                generatedImageDisplay.classList.remove('hidden');
                imagePlaceholderText.classList.add('hidden');
                imageGenerationLoader.classList.add('hidden');
                imageQuestionLoader.classList.remove('hidden'); 

                // 2. Generate Question about the Image with Gemini
                let baseGeminiImagePrompt = `Analyze this image. Generate a single, clear quiz question in Classical Arabic (Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰) specifically about the content or subject of this image. Provide four multiple-choice options also in Classical Arabic, with only one correct answer. Specify the index of the correct answer (0-3). The question should be engaging and directly related to what is visible in the image.`;
                let geminiImagePrompt = baseGeminiImagePrompt;
                if (askedQuestionsThisRound.length > 0) {
                    const exclusions = askedQuestionsThisRound.map(q => `"${q}"`).join(', ');
                    geminiImagePrompt += ` IMPORTANT: The textual part of this question must be different from any of the following textual questions that have already been asked in this round: [${exclusions}].`;
                }

                const geminiPayload = {
                    contents: [{
                        role: "user",
                        parts: [
                            { text: geminiImagePrompt },
                            { inlineData: { mimeType: "image/png", data: currentImageBase64 } }
                        ]
                    }],
                    generationConfig: questionGenerationSchema
                };
                const geminiResponse = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(geminiPayload) });
                if (!geminiResponse.ok) throw new Error(`Gemini API error (Image Question): ${geminiResponse.status}`);
                const geminiResult = await geminiResponse.json();
                
                imageQuestionLoader.classList.add('hidden');
                if (geminiResult.candidates && geminiResult.candidates[0].content && geminiResult.candidates[0].content.parts[0].text) {
                    const quizData = JSON.parse(geminiResult.candidates[0].content.parts[0].text);
                     if (quizData.question && quizData.options && quizData.options.length === 4 && quizData.correctAnswerIndex !== undefined) {
                        if (askedQuestionsThisRound.includes(quizData.question) && askedQuestionsThisRound.length < 5) { 
                            console.warn("Duplicate image question received, retrying...");
                            currentQuestionNumberInRound--; 
                            fetchNewImageChallenge();
                            return;
                        }
                        askedQuestionsThisRound.push(quizData.question); 
                        displayQuestion(quizData.question, quizData.options, quizData.correctAnswerIndex, imageQuestionTextElement);
                    } else throw new Error("Invalid data structure from Gemini API (Image Question).");
                } else throw new Error("No valid content in Gemini API response (Image Question).");

            } catch (error) {
                console.error('Error fetching image challenge:', error);
                imageGenerationLoader.classList.add('hidden');
                imageQuestionLoader.classList.add('hidden');
                imagePlaceholderText.classList.remove('hidden');
                imagePlaceholderText.textContent = 'Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¶ÙŠØ± ØªØ­Ø¯ÙŠ Ø§Ù„ØµÙˆØ±Ø©.';
                imageQuestionTextElement.textContent = 'Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¶ÙŠØ± ØªØ­Ø¯ÙŠ Ø§Ù„ØµÙˆØ±Ø©.';
                feedbackTextElement.textContent = `Ø®Ø·Ø£: ${error.message}`;
                newQuestionButton.disabled = false; newQuestionButton.classList.remove('disabled-button');
            }
        }


        function displayQuestion(question, options, correctAnswerIdx, questionElement) {
            currentQuestionFullText = question;
            currentOptions = options; 
            questionElement.textContent = currentQuestionFullText;
            currentCorrectAnswerIndex = correctAnswerIdx;
            currentCorrectOptionText = options[correctAnswerIdx];
            optionsContainerElement.innerHTML = ''; 
            whyWrongExplanationContainer.innerHTML = ''; 
            hintButton.classList.remove('hidden'); 
            hintButton.disabled = false; 
            hintContainer.innerHTML = ''; 

            options.forEach((option, index) => {
                const optionDiv = document.createElement('div'); 
                optionDiv.classList.add('flex', 'flex-col', 'items-start'); 

                const button = document.createElement('button');
                button.textContent = option;
                button.classList.add('option-button', 'w-full', 'p-2', 'sm:p-3', 'bg-slate-200', 'hover:bg-slate-300', 'text-slate-700', 'font-semibold', 'rounded-lg', 'border-2', 'border-slate-300', 'focus:outline-none', 'focus:ring-2', 'focus:ring-sky-500', 'text-sm', 'sm:text-base');
                button.dataset.index = index;
                button.addEventListener('click', handleOptionClick);
                
                optionDiv.appendChild(button);
                optionsContainerElement.appendChild(optionDiv);
            });
            feedbackTextElement.textContent = '';
            newQuestionButton.disabled = true; 
            newQuestionButton.classList.add('disabled-button'); 
            explainAnswerButton.classList.add('hidden'); 
            explanationContainer.innerHTML = ''; 
        }

        function handleOptionClick(event) {
            initializeTone(); 
            const selectedOptionButton = event.target;
            const selectedAnswerIndex = parseInt(selectedOptionButton.dataset.index);

            const optionButtons = optionsContainerElement.querySelectorAll('.option-button');
            optionButtons.forEach(btn => {
                btn.disabled = true;
                btn.classList.add('disabled-button');
            });
            hintButton.classList.add('hidden'); 
            whyWrongExplanationContainer.innerHTML = ''; 

            if (selectedAnswerIndex === currentCorrectAnswerIndex) {
                selectedOptionButton.classList.remove('bg-slate-200', 'hover:bg-slate-300', 'border-slate-300');
                selectedOptionButton.classList.add('correct');
                feedbackTextElement.textContent = 'Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©!';
                feedbackTextElement.classList.remove('text-red-500');
                feedbackTextElement.classList.add('text-green-500');
                score++;
                scoreElement.textContent = score;
                playCorrectAnswerSound();
            } else {
                selectedOptionButton.classList.remove('bg-slate-200', 'hover:bg-slate-300', 'border-slate-300');
                selectedOptionButton.classList.add('incorrect');
                feedbackTextElement.textContent = 'Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©.';
                feedbackTextElement.classList.remove('text-green-500');
                feedbackTextElement.classList.add('text-red-500');
                playIncorrectAnswerSound();

                optionButtons.forEach((btn, index) => {
                    if (index === currentCorrectAnswerIndex) {
                        btn.classList.remove('bg-slate-200', 'hover:bg-slate-300', 'border-slate-300');
                        btn.classList.add('correct');
                    } else if (index !== selectedAnswerIndex) { 
                        const whyWrongBtn = document.createElement('button');
                        whyWrongBtn.textContent = 'âœ¨ Ù„Ù…Ø§Ø°Ø§ Ù‡Ø°Ø§ Ø§Ù„Ø®ÙŠØ§Ø± Ø®Ø·Ø£ØŸ';
                        whyWrongBtn.classList.add('why-wrong-btn', 'action-btn', 'rounded-md');
                        whyWrongBtn.dataset.optionIndex = index;
                        whyWrongBtn.addEventListener('click', handleWhyWrongClick);
                        btn.parentElement.appendChild(whyWrongBtn); 
                    }
                });
            }
            explainAnswerButton.classList.remove('hidden'); 
            newQuestionButton.disabled = false; 
            newQuestionButton.classList.remove('disabled-button');
            if (currentQuestionNumberInRound >= totalQuestionsInRound) {
                newQuestionButton.textContent = "Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©";
            }
        }
        
        async function handleWhyWrongClick(event) {
            const button = event.target;
            button.disabled = true; 
            button.classList.add('disabled-button');
            const optionIndex = parseInt(button.dataset.optionIndex);
            const incorrectOptionText = currentOptions[optionIndex];
            
            const loader = document.createElement('div');
            loader.className = 'loader';
            loader.style.width = '20px'; 
            loader.style.height = '20px';
            loader.style.borderWidth = '3px';
            button.parentElement.appendChild(loader); 

            try {
                let prompt;
                let payloadContent = [];

                const basePrompt = `Ø§Ù„Ø³Ø¤Ø§Ù„ Ù‡Ùˆ: "${currentQuestionFullText}". Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù‡ÙŠ: "${currentCorrectOptionText}". Ù„Ù…Ø§Ø°Ø§ ÙŠØ¹ØªØ¨Ø± Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„ØªØ§Ù„ÙŠ Ø®Ø§Ø·Ø¦Ù‹Ø§: "${incorrectOptionText}"ØŸ Ù‚Ø¯Ù… Ø´Ø±Ø­Ù‹Ø§ Ù…ÙˆØ¬Ø²Ù‹Ø§ ÙˆÙˆØ§Ø¶Ø­Ù‹Ø§ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰.`;
                
                if (currentQuizMode === 'image' && currentImageBase64) {
                    prompt = `${basePrompt} Ø§Ø¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø±ÙÙ‚Ø© ÙÙŠ ØªØ­Ù„ÙŠÙ„Ùƒ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø°Ø§Øª ØµÙ„Ø©.`;
                    payloadContent.push({ text: prompt });
                    payloadContent.push({ inlineData: { mimeType: "image/png", data: currentImageBase64 } });
                } else {
                    prompt = basePrompt;
                    payloadContent.push({ text: prompt });
                }
                
                const payload = {
                    contents: [{ role: "user", parts: payloadContent }]
                };

                const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API error (Why Wrong): ${response.status}`);
                const result = await response.json();
                
                loader.remove(); 

                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                    const explanationText = result.candidates[0].content.parts[0].text;
                    const explanationDiv = document.createElement('div');
                    explanationDiv.classList.add('why-wrong-box', 'w-full'); 
                    explanationDiv.innerHTML = `<strong>Ù„Ù…Ø§Ø°Ø§ "${incorrectOptionText}" Ø®Ø·Ø£:</strong> ${explanationText}`;
                    whyWrongExplanationContainer.appendChild(explanationDiv); 
                } else {
                    throw new Error("No valid explanation for incorrect option.");
                }
            } catch (error) {
                loader.remove();
                console.error('Error fetching why wrong explanation:', error);
                const errorDiv = document.createElement('div');
                errorDiv.classList.add('why-wrong-box', 'text-red-700', 'w-full');
                errorDiv.textContent = `Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø´Ø±Ø­ Ù‡Ø°Ø§ Ø§Ù„Ø®ÙŠØ§Ø±: ${error.message}`;
                whyWrongExplanationContainer.appendChild(errorDiv);
            }
        }


        async function fetchHint() {
            hintButton.disabled = true;
            hintButton.classList.add('disabled-button');
            hintLoaderContainer.classList.remove('hidden');
            hintContainer.innerHTML = '';

            try {
                let prompt;
                let payloadContent = [];

                if (currentQuizMode === 'image' && currentImageBase64) {
                    prompt = `For the image provided, the current quiz question is: "${currentQuestionFullText}". Please provide a very short and subtle hint in Classical Arabic (Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰) that helps to answer the question without giving the answer away directly. The hint should be related to the image and the question.`;
                    payloadContent.push({ text: prompt });
                    payloadContent.push({ inlineData: { mimeType: "image/png", data: currentImageBase64 } });
                } else {
                    prompt = `The current quiz question is: "${currentQuestionFullText}". Please provide a very short and subtle hint in Classical Arabic (Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰) that helps to answer the question without giving the answer away directly.`;
                    payloadContent.push({ text: prompt });
                }
                
                const payload = {
                    contents: [{ role: "user", parts: payloadContent }]
                };

                const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API error (Hint): ${response.status}`);
                const result = await response.json();

                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                    const hintText = result.candidates[0].content.parts[0].text;
                    hintContainer.innerHTML = `<div class="hint-box">ğŸ’¡ ØªÙ„Ù…ÙŠØ­: ${hintText}</div>`;
                } else throw new Error("No valid hint content in API response.");
            } catch (error) {
                console.error('Error fetching hint:', error);
                hintContainer.innerHTML = `<div class="hint-box text-red-600">Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„ØªÙ„Ù…ÙŠØ­: ${error.message}</div>`;
            } finally {
                hintLoaderContainer.classList.add('hidden');
            }
        }


        async function fetchAnswerExplanation() {
            explainAnswerButton.disabled = true;
            explainAnswerButton.classList.add('disabled-button');
            explanationLoaderContainer.classList.remove('hidden');
            explanationContainer.innerHTML = '';

            try {
                let prompt;
                let payloadContent = [];
                let baseExplanationPrompt = `The question was: "${currentQuestionFullText}". The correct answer was: "${currentCorrectOptionText}". Please provide a brief and clear explanation (2-3 sentences) in Classical Arabic (Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰) why this answer is correct. The explanation must be in Arabic.`;

                if (currentQuizMode === 'image' && currentImageBase64) {
                    prompt = `${baseExplanationPrompt} Relate the explanation to the provided image if relevant.`;
                    payloadContent.push({ text: prompt });
                    payloadContent.push({ inlineData: { mimeType: "image/png", data: currentImageBase64 } });
                } else { // Text quiz mode
                    prompt = `${baseExplanationPrompt} After the explanation, on a new section titled 'ğŸ“š Ù…ÙØ±Ø¯Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©:', pick one or two key Arabic words from the question or the correct answer, and provide their definitions or synonyms in Classical Arabic.`;
                    payloadContent.push({ text: prompt });
                }
                
                const payload = {
                    contents: [{ role: "user", parts: payloadContent }]
                };

                const response = await fetch(geminiApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API error (Explanation): ${response.status}`);
                const result = await response.json();

                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                    let explanationText = result.candidates[0].content.parts[0].text;
                    const vocabMarker = "ğŸ“š Ù…ÙØ±Ø¯Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©:";
                    let mainExplanation = explanationText;
                    let vocabHtml = "";

                    if (explanationText.includes(vocabMarker)) {
                        const parts = explanationText.split(vocabMarker);
                        mainExplanation = parts[0].trim();
                        if (parts[1]) {
                            vocabHtml = `<h4 class="font-semibold mt-2 mb-1">${vocabMarker}</h4><p>${parts[1].trim().replace(/\n/g, '<br>')}</p>`;
                        }
                    }
                    explanationContainer.innerHTML = `<div class="explanation-box">${mainExplanation}${vocabHtml}</div>`;

                } else throw new Error("No valid explanation content in API response.");
            } catch (error) {
                console.error('Error fetching explanation:', error);
                explanationContainer.innerHTML = `<div class="explanation-box text-red-600">Ø¹Ø°Ø±Ù‹Ø§ØŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø´Ø±Ø­: ${error.message}</div>`;
            } finally {
                explanationLoaderContainer.classList.add('hidden');
                explainAnswerButton.disabled = false;
                explainAnswerButton.classList.remove('disabled-button');
            }
        }
        
        async function initializeQuizApp() { 
            isRoundActive = false;
            score = 0;
            scoreElement.textContent = score;
            currentQuestionNumberInRound = 0;
            totalQuestionsInRound = 0;
            currentRoundTopic = "";
            currentImageBase64 = null;
            askedQuestionsThisRound = []; 

            if (firebaseConfig && !auth?.currentUser) { 
                await signInUser(); // Await sign-in before loading categories
            } else if (firebaseConfig && auth?.currentUser) {
                 // If already signed in (e.g. on reset), load categories directly
                await loadAndUpdateCategories();
            } else {
                // No Firebase, use default topics
                dynamicTopicsData = { ...defaultTopicsData };
                populateMainTopics();
            }
            
            setQuizMode('text'); 

            questionTextElement.textContent = "Ø§Ø®ØªØ± ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨ØŒ Ø«Ù… Ø­Ø¯Ø¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ÙˆØ§Ø¶ØºØ· 'Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø©' Ù„Ù„Ø¨Ø¯Ø¡!";
            imageQuestionTextElement.textContent = "";
            generatedImageDisplay.classList.add('hidden');
            generatedImageDisplay.src = "https://placehold.co/400x250/e2e8f0/94a3b8?text=Ø³ÙŠØªÙ…+Ø¹Ø±Ø¶+Ø§Ù„ØµÙˆØ±Ø©+Ù‡Ù†Ø§";
            imagePlaceholderText.classList.remove('hidden');
            imagePlaceholderText.textContent = "Ø³ÙŠØªÙ… Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯Ù‡Ø§...";


            optionsContainerElement.innerHTML = '';
            feedbackTextElement.textContent = '';
            feedbackTextElement.classList.remove('text-red-500', 'text-green-500', 'text-sky-600');
            
            hintButton.classList.add('hidden');
            hintContainer.innerHTML = '';
            hintLoaderContainer.classList.add('hidden');
            explainAnswerButton.classList.add('hidden');
            explanationContainer.innerHTML = '';
            explanationLoaderContainer.classList.add('hidden');
            whyWrongExplanationContainer.innerHTML = '';
            imageGenerationLoader.classList.add('hidden');
            imageQuestionLoader.classList.add('hidden');
            
            roundProgressContainer.classList.add('hidden');
            roundProgressContainer.textContent = ''; 

            numQuestionsInput.disabled = false;
            numQuestionsInput.value = currentQuizMode === 'text' ? "5" : "3"; 
            mainTopicSelect.disabled = false;
            // Sub-topic select will be enabled/disabled by populateSubTopics based on main topic
            if (mainTopicSelect.value) { // Ensure it's called after main topics are populated
                 populateSubTopics();
            }


            newQuestionButton.textContent = "Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø©";
            newQuestionButton.disabled = false;
            newQuestionButton.classList.remove('disabled-button');

            textQuizModeButton.disabled = false; textQuizModeButton.classList.remove('disabled-button');
            imageQuizModeButton.disabled = false; imageQuizModeButton.classList.remove('disabled-button');
            if (currentQuizMode === 'text') {
                textQuizModeButton.classList.add('bg-sky-700', 'disabled-button');
                imageQuizModeButton.classList.remove('bg-sky-700', 'disabled-button');
                 imageQuizModeButton.classList.add('bg-sky-500', 'hover:bg-sky-600');
            } else {
                imageQuizModeButton.classList.add('bg-sky-700', 'disabled-button');
                textQuizModeButton.classList.remove('bg-sky-700', 'disabled-button');
                textQuizModeButton.classList.add('bg-sky-500', 'hover:bg-sky-600');
            }
        }

        // Event Listeners
        textQuizModeButton.addEventListener('click', () => setQuizMode('text'));
        imageQuizModeButton.addEventListener('click', () => setQuizMode('image'));

        newQuestionButton.addEventListener('click', () => {
            initializeTone(); 
            if (!isRoundActive) {
                startNewRound();
            } else {
                if (currentQuizMode === 'text') fetchNewTextQuestion();
                else if (currentQuizMode === 'image') fetchNewImageChallenge();
            }
        });
        hintButton.addEventListener('click', fetchHint);
        explainAnswerButton.addEventListener('click', fetchAnswerExplanation);
        resetGameButton.addEventListener('click', initializeQuizApp); 

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js').then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        initializeQuizApp(); 
    </script>
</body>
</html>
